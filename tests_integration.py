from aes import aes_encrypt_block


def test_nist_primary_vector():
    plaintext = [
        0x00,0x11,0x22,0x33,
        0x44,0x55,0x66,0x77,
        0x88,0x99,0xaa,0xbb,
        0xcc,0xdd,0xee,0xff
    ]
    key = [
        0x00,0x01,0x02,0x03,
        0x04,0x05,0x06,0x07,
        0x08,0x09,0x0a,0x0b,
        0x0c,0x0d,0x0e,0x0f
    ]
    expected = [
        0x69,0xc4,0xe0,0xd8,
        0x6a,0x7b,0x04,0x30,
        0xd8,0xcd,0xb7,0x80,
        0x70,0xb4,0xc5,0x5a
    ]
    assert aes_encrypt_block(plaintext, key) == expected


def test_nist_zero_vector():
    expected = [
        0x66,0xe9,0x4b,0xd4,0xef,0x8a,0x2c,0x3b,
        0x88,0x4c,0xfa,0x59,0xca,0x34,0x2b,0x2e
    ]
    assert aes_encrypt_block([0]*16, [0]*16) == expected


def test_regression_incrementing_plaintext():
    plaintext = list(range(16))
    key = [0x00] * 16
    expected = [
        0x0e,0xdd,0x33,0xd3,0xc6,0x21,0xe5,0x46,
        0xaa,0xbc,0xe5,0x2d,0xa4,0x45,0x5a,0xc1
    ]
    assert aes_encrypt_block(plaintext, key) == expected


def test_consistent_repeated_calls():
    plaintext = [0x10] * 16
    key = [0x20] * 16
    out1 = aes_encrypt_block(plaintext, key)
    out2 = aes_encrypt_block(plaintext, key)
    assert out1 == out2
